(** Advanced recursive functions *)
(** Recursion using Function *)

Require Import FunInd.
Require Import Coq.Lists.List.
Require Import Arith.
Require Import Recdef.
Require Import Program.
Load CpdtTactics.


(* Using {struct n} 
   structural recursive function - 
   like Fixpoint 
*)

Function plus (m n : nat) {struct n} : nat :=
match n with
| 0 => m
| S p => S (plus m p)
end.

(* Using {measure n} 
   non-structural recursive function 
*)

Function revapp (m n : list nat) {measure length n} :=
match n with
| nil => m
| _   => cons (hd 0 n) (revapp m (tl n))
end.
intros. eauto.
Defined.

(** Equal equation to get rid of the decreasing lemma in subsequent proofs *)
Check revapp_equation.

Definition lengthOrder (x y:list nat) :=
   length x < length y.

Hint Constructors Acc.

Theorem lengthOrder_wf' : forall len,
     forall ls, length ls <= len -> 
          Acc lengthOrder ls.
Proof. 
unfold lengthOrder; induction len; crush.
Qed.

Function revapp_ (m n : list nat) {wf lengthOrder n} :=
match n with
| nil => m
| _   => cons (hd 0 n) (revapp_ m (tl n))
end.
intros. simpl. unfold lengthOrder. eauto.
unfold well_founded. intro. 
eapply lengthOrder_wf'. auto.
Defined.

Check revapp_equation.

(** Tactic functional induction (qualid term+) *)
(* The tactic functional induction performs case analysis and induction
   following the definition of a function. It makes use of a principle 
   generated by Function or Functional Scheme. 
*)

Functional Scheme revapp_ind := Induction for revapp Sort Prop.

Check revapp_ind.

(** ?? func_ind only possible for simple(?) cases*)

(** Simple example proof with functional induction*)

Functional Scheme minus_ind := Induction for minus Sort Prop.

Check minus_ind.

Lemma le_minus (n m:nat) : n - m <= n.
(* 1 subgoal
  
  n, m : nat
  ============================
  n - m <= n
*)
functional induction (minus n m) using minus_ind; simpl; auto.

Qed.


(** using program fixpoint - nested recursion is possible*)

Program Fixpoint revapp' (m n : list nat) {measure (length n)}  :=
  match n with
  | nil => m
  | _   => cons (hd 0 n) (revapp' m (tl n))
  end.

Obligations.



Print All.

(** Diff between Program Fixpoint and Function *)
(* As you already mentioned, Program Fixpoint allows the measure to look at more than one argument.
Function creates a foo_equation lemma that can be used to rewrite calls to foo with its RHS. Very useful to avoid problems like Coq simpl for Program Fixpoint.
In some (simple?) cases, Function can define a foo_ind lemma to perform induction along the structure of recursive calls of foo. Again, very useful to prove things about foo without effectively repeating the termination argument in the proof.
Program Fixpoint can be tricked into supporting nested recursion, see https://stackoverflow.com/a/46859452/946226. This is also why Program Fixpoint can define the Ackermann function when Function cannot.*)